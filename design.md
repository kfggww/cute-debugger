# 需求分析

## 要解决什么问题
简而言之, 写一个程序, 能够控制并且检查另一个程序的运行状态.

### 1. 如何控制?
设置断点

### 2. 检查什么, 怎么检查?
检查另一个程序的变量, 内存, 调用堆栈

### 3. 用户的典型使用场景
1. 打开调试器
2. 接受用户命令
3. 执行命令
4. 等待结果
5. 调试器退出

### 4. 支持什么命令?
1. start
2. break
3. tbreak
4. print
5. set
6. step
7. stepi
8. next
9. nexti
10. continue
11. finish
12. list
13. info
14. quit

### 5. 设置断点的原理
ptrace

### 6. 断点的地址怎么获取
调试信息保存在elf的段中, 使用libdwarf可以读取调试信息的数据, 包括:

- 函数和地址的对应关系
- 行号和地址的对应关系

对于PIE类型的可执行程序, 需要获取实际的加载地址, 然后加上从调试信息中获取的地址偏移, 才能得到在进程地址空间中的真实地址.

### 7. 类和对象信息
- Debugger
  
  1. 代表调试器
  2. 管理被调试程序, 可以有多个
  3. 管理用户的使用逻辑


- Tracee
  
  1. 代表一个被调试的进程
  2. 记录当前有哪些断点, 统计断点的历史信息
  3. 负责断点的设置, 删除, enable, disable等操作
  4. 控制被调试进程的执行
  5. 其中3, 4就是Tracee对它能接受的命令的响应
  6. 考虑一下对不同cpu的支持


- Command

  1. 对用户输入的包装
  2. Debugger和Tracee都是一种命令处理器, 用户输入的命令会经由二者组成的过滤器, 最终得到响应

- DebugInfoDB
  
  1. 维护tracee的调试信息, 函数, 变量, 行号 <--> 地址
  2. 每个tracee都需要持有自己的debuginfodb
  3. 可以对底层libdwarf查到的结果做一层缓存, 加快查找的速度


- BreakPoint

  1. 代表一个断点
  2. 记录断点的地址数据
  3. 原始指令
  4. 命中次数